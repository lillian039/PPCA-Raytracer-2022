## Unity Shader 学习笔记

#### GPU 流水线

- ##### 应用阶段：

  输出渲染所需的几何信息

  - 将数据加载到显存中：准备好场景数据，如摄像机位置，锥视体，光源，模型顶点的位置信息，法线方向，顶点坐标，纹理坐标等等
  - 粗粒度剔除：将不可见物品剔除
  - 设置渲染状态：如使用的材质，使用的纹理，使用的着色器，光源属性等等
  - 调用 Draw Call 从CPU 将需要被渲染的图元发送到 GPU，指向一个需要被渲染的图元列表，图元可以是点、线、三角形等等

  **一些该阶段的优化：**

  CPU 与 GPU 如何并行工作：命令缓冲区。

  Draw Call 多了会影响帧率：CPU 会将大量时间花费在提交 Draw Call 上

  减少 Draw Call 的方法：批处理，将同一种渲染状态的物品合并

  **输出信息**：渲染图元

- ##### 几何阶段：

  - 顶点着色器：进行坐标变换，如输出每个顶点对应的纹理坐标，并进行逐顶点光照，
  - 裁剪：将不在摄像机视野范围内的物品减除
  - 屏幕映射：将图元的 x 和 y 坐标转换到屏幕坐标系下，屏幕坐标系与 z 轴一起构成窗口坐标系

  **输出信息**：屏幕坐标系下顶点位置，深度值，法线方向，视角方向等。

- **光栅化阶段：**

  计算每个图元覆盖了那些像素，为这些像素计算颜色

  - 三角形设置：通过三角形顶点计算出每条边上的像素坐标，表示出三角形的边界

  - 三角形遍历：利用上一阶段的计算结果，检查每个像素是否被一个三角形网格所覆盖，如果有，就生成一个片元，并使用三角形网格三个顶点的顶点信息对整个覆盖区域的像素进行插值。

    输出一个片元序列：片元，一个状态集合，包括屏幕坐标，深度信息，法线，纹理坐标等等，用于计算每个像素的最终颜色

  - 片元着色器：

    纹理采样：对纹理坐标进行插值，得到覆盖的片元的坐标

    逐像素光照

  - 逐片元操作：合并

    决定每个片元的可见性

    - 模板测试：

      通过开发者自行设定的函数，决定片元的舍弃或保留，并设置保留方式，模板缓冲区可被模板测试结果和深度测试结果修改

    - 深度测试：

      把片元的深度值与已存在在深度缓冲区中的值比较，判断是否舍弃。

    将通过测试的片元与已经存储在颜色缓冲区中的颜色进行混合

    - 混合：取出片元着色器得到的颜色值与已经存在颜色缓冲区中的颜色值进行合并

    Early-Z ：将深度测试提前 


#### 基础光照

- 标准光照模型：

  只关心直接光照，把进入摄像机分为四个部分，每个部分使用一种方法计算它的贡献度，分为四个部分

  - **自发光：**

    给定一个方向后，一个表面本身会向该方向发射多少辐射量（不会照亮周围的物品）

    直接使用该材质的自发光颜色

    $c_{emissive}=m_{emissive}$

  - **高光反射：**在完全镜面反射方向散射多少辐射量

    经验模型

    **$Phong$ 模型：**

    反射方向：$r=2·(n·I)·n-I$

    $c_{spscular}=(c_{light}\ ·m_{spscular})·max(0,v·r)^{m_{gloss}}$

    **$Blinn$ 模型：**

    $h=\frac{v+I}{|v+I|}$    避免计算反射方向，引入对视角方向和入射光线方向取平均再归一化得到的向量h

    $c_{spscular}=(c_{light}\ ·m_{spscular})·max(0,n·h)^{m_{gloss}}$

    **半兰伯特光照模型：**

    $c_{spscular}=(c_{light}\ ·m_{spscular})·(\alpha(n·I)+\beta\ )$

    从 [-1,1] 映射到 [0,1]  范围内，视觉上加强

  - **漫反射：**向每个方向散射多少辐射量 

    符合 Lambert‘s Law：反射光线的强度与表面法线和光源间的夹角余弦成正比

    $c_{diffuse}=(c_{light}\ ·m_{diffuse})·max(0,n·I)$

    $m$：漫反射材质的颜色

    $c_{light}$：光源颜色

    $I$：指向光源的单位矢量

    $n$：表面法线

  - **环境光：**描述所有间接光照，该模型中，为一个全局变量

    $c_{ambient}=g_{ambient}$

  逐像素光照：（在片元着色器中）

  以每个像素为基础，得到它的法线，进行光照模型运算

  逐顶点光照：（在顶点着色器中）

  在每个顶点上计算光照，然后在渲染的图元内部进行线性插值（当模型中有非线性计算就会有问题）

- 阴影是如何实现的：

  利用光源计算阴影映射纹理（Shadow Map），本质上也是一张深度图

  将摄像机放置到光源的位置上，调用该Pass，通过对顶点的变换后得到光源空间下的位置，并据此来输出深度信息到阴影映射纹理中

#### 纹理

- 单张纹理

- 凹凸映射

  法线纹理：存储表面的法线方向分量

  有两种存储方式：模型空间的法线纹理，切线空间的法线纹理

- 渐变纹理

  使用渐变纹理控制漫反射光照的效果

- 遮罩纹理

  允许我们保护某些区域，使他们免于某些修改

- 立方体纹理

  立方体纹理是环境映射的一种实现方式，环境映射可以模拟物体周围的环境，使用了环境映射的物体可以反射周围的环境

  立方体纹理采样需要提供一个三维的纹理坐标，表示世界空间下的3D方向，从立方体中心出发，向外部延伸，与立方体的纹理发生相交，采样的结果就由交点计算而来

  立方体纹理不能模拟多次反射的结果

  环境映射的最常见应用：反射与折射

#### 透明效果

- 透明度混合：需要关闭深度写入，渲染顺序很重要，先渲染不透明物体，再按照透明物品距离相机的远近进行排序，从后往前渲染

  如果物品相互重叠，可以把物品拆分成，然后再进行正确的排序

  渲染队列：决定渲染的顺序

  透明度混合：$DstColor_{new}=SrcAlpha×SrcColor+(1-SrcAlpha)×DstColor_{old}$

#### 屏幕后处理

卷积

边缘检测：

利用边缘检测算子，进行卷积计算梯度，判断边缘点

高斯模糊

利用高斯核计算
